/*
    This file was generated automatically by Alchitry Labs 2.0.29-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module variable_timer #(
        parameter SEED = 30'h286b4b9c,
        parameter FAST_CLOCK_DIV = 4'ha
    ) (
        input wire clk,
        input wire rst,
        output reg out,
        output reg [15:0] debug
    );
    localparam GENERATE_NUMBER_CLOCK_SPEED = FAST_CLOCK_DIV + 1'h1;
    localparam _MP_SIZE_1118385593 = 1'h1;
    localparam _MP_DIV_1118385593 = FAST_CLOCK_DIV;
    localparam _MP_TOP_1118385593 = 1'h0;
    localparam _MP_UP_1118385593 = 1'h1;
    logic [0:0] M_seed_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_1118385593),
        .DIV(_MP_DIV_1118385593),
        .TOP(_MP_TOP_1118385593),
        .UP(_MP_UP_1118385593)
    ) seed_clock (
        .clk(clk),
        .rst(rst),
        .value(M_seed_clock_value)
    );
    
    
    localparam _MP_SIZE_847743909 = 1'h1;
    localparam _MP_DIV_847743909 = GENERATE_NUMBER_CLOCK_SPEED;
    localparam _MP_TOP_847743909 = 1'h0;
    localparam _MP_UP_847743909 = 1'h1;
    logic [0:0] M_generate_next_number_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_847743909),
        .DIV(_MP_DIV_847743909),
        .TOP(_MP_TOP_847743909),
        .UP(_MP_UP_847743909)
    ) generate_next_number_clock (
        .clk(clk),
        .rst(rst),
        .value(M_generate_next_number_clock_value)
    );
    
    
    localparam _MP_SEED_1611164351 = 33'h19430f418;
    logic M_random_number_next;
    logic [31:0] M_random_number_seed;
    logic [31:0] M_random_number_num;
    
    pn_gen #(
        .SEED(_MP_SEED_1611164351)
    ) random_number (
        .clk(clk),
        .rst(rst),
        .next(M_random_number_next),
        .seed(M_random_number_seed),
        .num(M_random_number_num)
    );
    
    
    localparam _MP_RISE_1772508649 = 1'h1;
    localparam _MP_FALL_1772508649 = 1'h1;
    logic M_edge_detector_next_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1772508649),
        .FALL(_MP_FALL_1772508649)
    ) edge_detector_next (
        .in(M_generate_next_number_clock_value),
        .clk(clk),
        .out(M_edge_detector_next_out)
    );
    
    
    localparam _MP_RISE_2068773277 = 1'h1;
    localparam _MP_FALL_2068773277 = 1'h1;
    logic M_edge_detector_seed_out;
    
    edge_detector #(
        .RISE(_MP_RISE_2068773277),
        .FALL(_MP_FALL_2068773277)
    ) edge_detector_seed (
        .in(M_seed_clock_value),
        .clk(clk),
        .out(M_edge_detector_seed_out)
    );
    
    
    logic [15:0] D_seed_d, D_seed_q = 0;
    logic [4:0] pointer;
    always @* begin
        D_seed_d = D_seed_q;
        
        out = 1'h0;
        M_random_number_seed = D_seed_q;
        M_random_number_next = M_edge_detector_next_out;
        pointer = M_random_number_num[3'h4:1'h0];
        debug = M_random_number_num[4'hf:1'h0];
        if (M_edge_detector_seed_out) begin
            D_seed_d = D_seed_q + 1'h1;
        end
        out = M_random_number_num[pointer];
    end
    
    
    always @(posedge (clk)) begin
        D_seed_q <= D_seed_d;
        
    end
endmodule